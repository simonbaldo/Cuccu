/*
D11  matrix display, pin DIN
D13  matrix display, pin CLK
D10  matrix display, pin CS
D09  Servo control
D02  Software serial TX
D03  Software serial RX
D07  Pulsante impostazioni + variabile Pull Down
D12  Pulsante impostazioni cambio menu Pull Down
A04  RTC module, pin SDA // In arduino uno SDA ed SCL sono internamente collegati ad A4 ed A5
A05  RTC module, pin SCL //
A02  Pin per lettura fototransistor
*/

#include <Wire.h>
#include "LedControl.h"
#include <Servo.h>
#include "Pulsante.h"
#include "MyTimer.h"
#include "SoftwareSerial.h"
#include "DFRobotDFPlayerMini.h"
#include <EEPROM.h>

MyTimer tm(500);     //imposto un timer per la visualizzazione ora ogni 500 mSec
MyTimer tcucu(2000); //timer per rintocchi del cuccu ogni 2 sec

SoftwareSerial ss(3, 2); //RX, TX
DFRobotDFPlayerMini mp3;
byte suono;
byte volume;

//definizione pin per fotodiodo
const byte pinLuce=A2;
const byte pinLuce2=A1;
uint8_t iLuce=0;
uint8_t iLuce2=0;

//definizione pulsante
Pulsante p2(12, 3);
Pulsante p1(7, 3); 

//definizine servo
#define servoPin 9
Servo sc;
bool openBird=false;

//RTC DS1307
#define DS1307_I2C_ADDRESS 0x68 //address of DS1307 module
byte second, minute=99, hour, dayOfWeek, dayOfMonth, month, year; //global variables

bool closedCucu=false;
bool showDots=true;
bool lp1=false;
bool lp2=false;

//variabili per cucu
bool startCucu=false;
bool endCucu=true;
byte numeroCucu;
byte rintocchi;
bool statoCucu=true;

uint8_t pressP1=0;
uint8_t pressP2=0;
bool modImpo=false;
uint8_t menuImpo=0;
byte ora;
byte min;
byte oraImpo;
byte minImpo;
byte brt=0;

#define pinCLK 13
#define pinCS 10
#define pinDIN 11

#define ELEMENTS 4
LedControl lc = LedControl(pinDIN, pinCLK, pinCS, ELEMENTS);  

byte alpha[23][8] = {
{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0020 (space) 0
{ 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00 },   // U+0030 (0)     1
{ 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00 },   // U+0031 (1)     2
{ 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00 },   // U+0032 (2)     3
{ 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00 },   // U+0033 (3)     4
{ 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00 },   // U+0034 (4)     5
{ 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00 },   // U+0035 (5)     6
{ 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00 },   // U+0036 (6)     7
{ 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00 },   // U+0037 (7)     8
{ 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00 },   // U+0038 (8)     9
{ 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00 },   // U+0039 (9)    10
{ 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00 },   // U+0042 (B)    11
{ 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00 },   // U+0048 (H)    12
{ 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00 },   // U+004D (M)    13
{ 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00 },   // U+004C (L)    14
{ 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00 },   // U+0043 (C)    15
{ 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00 },   // U+004E (N)    16
{ 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00 },   // U+004F (O)    17
{ 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00 },   // U+0046 (F)    18
{ 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00 },   // U+0056 (V)    19
{ 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00 },   // U+0053 (S)    20
{ 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00 },   // U+0045 (E)    21
{ 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00 }    // U+0050 (P)    22
};

/*
byte alpha[95][8] = {
{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0020 (space)
{ 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00 },   // U+0021 (!)
{ 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0022 (")
{ 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00 },   // U+0023 (#)
{ 0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00 },   // U+0024 ($)
{ 0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00 },   // U+0025 (%)
{ 0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00 },   // U+0026 (&)
{ 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0027 (')
{ 0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00 },   // U+0028 (()
{ 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00 },   // U+0029 ())
{ 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00 },   // U+002A (*)
{ 0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00 },   // U+002B (+)
{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06 },   // U+002C (,)
{ 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00 },   // U+002D (-)
{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00 },   // U+002E (.)
{ 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00 },   // U+002F (/)
{ 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00 },   // U+0030 (0)
{ 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00 },   // U+0031 (1)
{ 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00 },   // U+0032 (2)
{ 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00 },   // U+0033 (3)
{ 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00 },   // U+0034 (4)
{ 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00 },   // U+0035 (5)
{ 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00 },   // U+0036 (6)
{ 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00 },   // U+0037 (7)
{ 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00 },   // U+0038 (8)
{ 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00 },   // U+0039 (9)
{ 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00 },   // U+003A (:)
{ 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06 },   // U+003B (//)
{ 0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00 },   // U+003C (<)
{ 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00 },   // U+003D (=)
{ 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00 },   // U+003E (>)
{ 0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00 },   // U+003F (?)
{ 0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00 },   // U+0040 (@)
{ 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00 },   // U+0041 (A)
{ 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00 },   // U+0042 (B)
{ 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00 },   // U+0043 (C)
{ 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00 },   // U+0044 (D)
{ 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00 },   // U+0045 (E)
{ 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00 },   // U+0046 (F)
{ 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00 },   // U+0047 (G)
{ 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00 },   // U+0048 (H)
{ 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00 },   // U+0049 (I)
{ 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00 },   // U+004A (J)
{ 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00 },   // U+004B (K)
{ 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00 },   // U+004C (L)
{ 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00 },   // U+004D (M)
{ 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00 },   // U+004E (N)
{ 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00 },   // U+004F (O)
{ 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00 },   // U+0050 (P)
{ 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00 },   // U+0051 (Q)
{ 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00 },   // U+0052 (R)
{ 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00 },   // U+0053 (S)
{ 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00 },   // U+0054 (T)
{ 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00 },   // U+0055 (U)
{ 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00 },   // U+0056 (V)
{ 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00 },   // U+0057 (W)
{ 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00 },   // U+0058 (X)
{ 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00 },   // U+0059 (Y)
{ 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00 },   // U+005A (Z)
{ 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00 },   // U+005B ([)
{ 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00 },   // U+005C (\)
{ 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00 },   // U+005D (])
{ 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00 },   // U+005E (^)
{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF },   // U+005F (_)
{ 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0060 (`)
{ 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00 },   // U+0061 (a)
{ 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00 },   // U+0062 (b)
{ 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00 },   // U+0063 (c)
{ 0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00 },   // U+0064 (d)
{ 0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00 },   // U+0065 (e)
{ 0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00 },   // U+0066 (f)
{ 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F },   // U+0067 (g)
{ 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00 },   // U+0068 (h)
{ 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00 },   // U+0069 (i)
{ 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E },   // U+006A (j)
{ 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00 },   // U+006B (k)
{ 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00 },   // U+006C (l)
{ 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00 },   // U+006D (m)
{ 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00 },   // U+006E (n)
{ 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00 },   // U+006F (o)
{ 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F },   // U+0070 (p)
{ 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78 },   // U+0071 (q)
{ 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00 },   // U+0072 (r)
{ 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00 },   // U+0073 (s)
{ 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00 },   // U+0074 (t)
{ 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00 },   // U+0075 (u)
{ 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00 },   // U+0076 (v)
{ 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00 },   // U+0077 (w)
{ 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00 },   // U+0078 (x)
{ 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F },   // U+0079 (y)
{ 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00 },   // U+007A (z)
{ 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00 },   // U+007B ({)
{ 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00 },   // U+007C (|)
{ 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00 },   // U+007D (})
{ 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+007E (~)
};
*/
/*
byte reverse_byte(byte x)
{
    static const byte table[] = {
        0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
        0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
        0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
        0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
        0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
        0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
        0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
        0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
        0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
        0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
        0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
        0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
        0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
        0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
        0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
        0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
        0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
        0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
        0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
        0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
        0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
        0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
        0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
        0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
        0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
        0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
        0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
        0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
        0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
        0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
        0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
        0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
    };
        return table[x];
}
*/
byte ByteRevers(byte in) {

  //return  reverse_byte(in);
	//font turning
  
	byte out;
	out = 0;
	if (in & 0x01) out |= 0x80;
	if (in & 0x02) out |= 0x40;
	if (in & 0x04) out |= 0x20;
	if (in & 0x08) out |= 0x10;
	if (in & 0x10) out |= 0x08;
	if (in & 0x20) out |= 0x04;
	if (in & 0x40) out |= 0x02;
	if (in & 0x80) out |= 0x01;
	return(out);
  
}

void DrawSymbol(byte adr, byte symbol, byte offset) {
	//draw symbol
	//offset move the symbol to right side

	for (int i = 0; i <= 7; i++) {
		byte dataRow = alpha[symbol][i];
		dataRow = ByteRevers(dataRow) >> offset;
		lc.setRow(adr, i, dataRow);
	}
}

//conversion Dec to BCD 
byte decToBcd(byte val) {
	return((val / 10 * 16) + (val % 10));
}

//conversion BCD to Dec 
byte bcdToDec(byte val) {
	return((val / 16 * 10) + (val % 16));
}

void SetRtc(byte second, byte minute, byte hour, byte dayOfWeek, byte dayOfMonth, byte month, byte year) {
	Wire.beginTransmission(DS1307_I2C_ADDRESS);
	Wire.write(0); //set 0 to first register

	Wire.write(decToBcd(second)); //set second
	Wire.write(decToBcd(minute)); //set minutes 
	Wire.write(decToBcd(hour)); //set hours
	Wire.write(decToBcd(dayOfWeek)); //set day of week (1=su, 2=mo, 3=tu) 
	Wire.write(decToBcd(dayOfMonth)); //set day of month
	Wire.write(decToBcd(month)); //set month
	Wire.write(decToBcd(year)); //set year
	Wire.endTransmission();
}


//read RTC
void GetRtc() {
	Wire.beginTransmission(DS1307_I2C_ADDRESS);
	Wire.write(0); //write "0"
	Wire.endTransmission();

	Wire.requestFrom(DS1307_I2C_ADDRESS, 7);	//request - 7 bytes from RTC
	second = bcdToDec(Wire.read() & 0x7f);
  minute = bcdToDec(Wire.read());
	hour = bcdToDec(Wire.read() & 0x3f);

	dayOfWeek = bcdToDec(Wire.read());
	dayOfMonth = bcdToDec(Wire.read());
	month = bcdToDec(Wire.read());
	year = bcdToDec(Wire.read());
}

void WriteTime() {
	//write time to matrix display
	//if (systemState == 0 || systemState == 2) {
  //orario in 12h
  // uint8_t hour12 = hour%12 == 0? 12 : hour%12;
  //orario in 24h
  uint8_t hour12 = hour;
	DrawSymbol(2, (hour12 % 10) + 1, 0);
	DrawSymbol(3, (hour12 / 10) + 1, 0);
	//}

	//if (systemState == 0 || systemState == 3) {
	DrawSymbol(0, (minute % 10) + 1, 1);
	DrawSymbol(1, (minute / 10) + 1, 1);
	//}
	
	//blinking dots on display
	lc.setLed(2, 1, 7, showDots);  //addr, row, column
	lc.setLed(2, 2, 7, showDots);
	lc.setLed(2, 5, 7, showDots);
	lc.setLed(2, 6, 7, showDots);

	showDots = !showDots;
}

void WriteImpo() {
	//write time to matrix display
	//if (systemState == 0 || systemState == 2) {
  //orario in 12h
  // uint8_t hour12 = hour%12 == 0? 12 : hour%12;
  //orario in 24h
  if (menuImpo==0) {      
	  	DrawSymbol(0, (ora % 10) + 1, 0);
		  DrawSymbol(1, (ora / 10) + 1, 0);
  		DrawSymbol(2, 0, 1);  //Space
	  	DrawSymbol(3, 12, 1); //H	  
  }
  else
  //minuti
  if (menuImpo==1) {      
	  	DrawSymbol(0, (min % 10) + 1, 0);
		  DrawSymbol(1, (min / 10) + 1, 0);
  		DrawSymbol(2, 0, 1);  //Space
	  	DrawSymbol(3, 13, 1); //M
  }
  else
  //luminosità
  if (menuImpo==2) {      
	  	DrawSymbol(0, (brt % 10) + 1, 0);
		  DrawSymbol(1, (brt / 10) + 1, 0);
  		DrawSymbol(2, 0, 1);  //Space
	  	DrawSymbol(3, 14, 1); //L	  
      for (int i = 0; i < ELEMENTS ; i++) {
           lc.setIntensity(i,brt);  // 0-15
      }
  }
  else 
    //Attivo/disattivo cucu
    if (menuImpo==3) {
      if (statoCucu) {  
          DrawSymbol(0, 16, 0); //N
          DrawSymbol(1, 17, 0); //O 
          DrawSymbol(2, 0,  1); //Space
          DrawSymbol(3, 15, 1); //C
      }
      else {
          DrawSymbol(0, 18, 0); //F
          DrawSymbol(1, 18, 0); //F
          DrawSymbol(2, 17, 0); //O
          DrawSymbol(3, 15, 1); //C
      }
  }
  else
    //Volume
    if (menuImpo==4){
    	  	DrawSymbol(0, (volume % 10) + 1, 0);
		      DrawSymbol(1, (volume / 10) + 1, 0);
          DrawSymbol(2, 0,  1); //Space
          DrawSymbol(3, 19, 1); //V
  }  
  else
    //Tipo suono cucu
    if (menuImpo==5) {
    	  	DrawSymbol(0, (suono % 10) + 1, 0);
		      DrawSymbol(1, (suono / 10) + 1, 0);
          DrawSymbol(2, 0,  1); //Space
          DrawSymbol(3, 20, 1); //S
    }
  else
    //apertura/chiusura Cucu
    if (menuImpo==6) {
      if (openBird) {  
          DrawSymbol(0, 16, 0); //N
          DrawSymbol(1, 21, 0); //E
          DrawSymbol(2, 22, 0); //P
          DrawSymbol(3, 17, 0); //O
      }
      else {
          DrawSymbol(0, 20, 0); //S
          DrawSymbol(1, 17, 0); //O 
          DrawSymbol(2, 14, 0); //L
          DrawSymbol(3, 15, 0); //C
      }

    }  

}

//callback di visualizzazione dell'ora
void visOra() {
	
  GetRtc();		//get actual time

  if (!modImpo)
    WriteTime();	//write actual time to matrix display
  else
    WriteImpo();  	

}

//verifica della pressione dei pulsanti per impostazione dell'ora
void testPressedButton() {
	
	//la funzione released() restituisce al rilascio del pulsante i valori: 
	//0 - tasto non premuto
	//1 - tasto premuto
	//2 - pressione prolungata del tasto
	
  pressP2=p2.released();
  pressP1=p1.released();

   if (pressP1==2) 
      lp1=true;

   if (pressP1==2) 
      lp2=true;

    //pressione prolungata di P1 e P2 entro in modalità impostazioni
    if (lp2 && lp1) {
        lp1=false;
        lp2=false;
        if (!modImpo) {
          modImpo=true;
          menuImpo=0;
          ora=hour;
          min=minute;
          oraImpo=ora;
          minImpo=min;
        }
      return;
      } 
  
  //menuImpo = 0 - set Ora
  //menuImpo = 1 - set Minuti
  //menuImpo = 2 - set Luminosità
  //menuImpo = 3 - stato cucu (attivo/disattivo)
  //menuImpo = 4 - volume da 0 a 30
  //menuImpo = 5 - Tipo suono cucu
  //menuImpo = 6 - Apri/chiudi cucu

  if  (modImpo==true) {
    if (pressP1==1) {
        if (menuImpo==0) {
           ora++;
           if (ora>23)
              ora=0;
        }
        else
        if (menuImpo==1) {
          min++;
          if (min>59)
             min=0;
        }      
        else 
        if (menuImpo==2) {
          brt++;
          if (brt>15)
             brt=0;
        }
        else 
        if (menuImpo==3) 
           statoCucu=!statoCucu;
        else
        if (menuImpo==4) {
            volume++;
            if (volume>30)
              volume=0;
            mp3.volume(volume);
            mp3.play(suono);  
        }
        else
        if (menuImpo==5) {
           suono++;
           if (suono>7)
              suono=1;
           mp3.play(suono);   
        }
        else
        if (menuImpo==6) {
          if (openBird) {
            openBird=false;
            sc.write(0);
          }
          else {
            openBird=true;
            sc.write(180);
          }

        }
              
    }
    else
    if (pressP2==1) {
        menuImpo++;
        if (menuImpo>6) {
          modImpo=false;
          //se ho cambiato ora o minuti quando sono entrato in impostazioni aggiorno
          if (ora!=oraImpo || min!=minImpo)
             SetRtc(second, min, ora, dayOfWeek, dayOfMonth, month, year);	//sec, min, hour, dayOfWeek, dayOfMonth, month, year

          EEPROM.write(0, statoCucu);
          EEPROM.write(1,brt);
          EEPROM.write(2,suono);
          EEPROM.write(3,volume);

          if (openBird)  
             sc.write(0);
          openBird=false;             

        }
    }

  }
}

void openCucu() {
  sc.write(180);
  delay(1000);
}

void closeCucu() {

  if (closedCucu)
     return;

  closedCucu=true;
  sc.write(0);
  delay(1000);
}

void testCucu() {

   if (!modImpo) {

      if (minute==0 && hour>=7 && hour<=21) {
        //controllo luminosità
        iLuce = analogRead(pinLuce);
        iLuce2 = analogRead(pinLuce2);
        delay(5);        
        //se per entrambi i fotodiodi non è buio (buio ha un valore <30 ) alloro posso far partire il cucu 
        if (!startCucu && !(iLuce<=30 && iLuce2 <= 30)) { 
          if (statoCucu==true) {
             startCucu=true;
             endCucu=false;
             closedCucu=false;
             openCucu();
             if (hour > 12) {
                numeroCucu = hour - 12;
             }
             else {     
                numeroCucu = hour;
             }   
             rintocchi=0;
         }
        } 
     }
   }

   if (!modImpo) {
      if (endCucu && startCucu) {
          closeCucu();
      }
   } 

   if (!modImpo) {
      if (minute==01) {
          if (endCucu && startCucu)
            startCucu = false;    
      }
   } 
   //i rintocchi del cucu vengono fatti attraverso il timer tcucu (impostato a 2 sec)
}

//callback richiamata dal timer del cuccu ogni 2 secondi
void playCucu() {

  if (!startCucu)
    return;
  
  if (rintocchi==numeroCucu) {
    endCucu=true;
    return;
  }

  rintocchi++;

  //Serial.print(rintocchi);
  //Serial.print("/");
  //Serial.println(numeroCucu);

   mp3.play(suono);

}

void setup() {

  //impostazioni di "fabbrica"
  //statoCucu=true;
  //brt=0;
  //suono=1;
  //volume=20;

  //EEPROM.write(0, statoCucu);
  //EEPROM.write(1,brt);
  //EEPROM.write(2,suono);
  //EEPROM.write(3,volume);
  //fine impostazioni di "fabbrica"

  statoCucu=EEPROM.read(0);
  brt=EEPROM.read(1);
  suono=EEPROM.read(2);
  volume=EEPROM.read(3);
  
  //begin software serial
  ss.begin(9600);

  Wire.begin(); //start I2C communication
  
  Serial.begin(9600);
  
  if (!mp3.begin(ss)) {
    Serial.println("errore mp3");
    for(;;);  
  }

  //inizializzazione mp3 player
  mp3.volume(volume);
  
  //inizializzazione matrice di led
  for (int i = 0; i < ELEMENTS ; i++) {
    lc.shutdown(i,false);  // Wake up displays  
    lc.setIntensity(i,brt);  // 0-15
    lc.clearDisplay(i);  // Clear Displays
  }

  //inizializzazione servo
  sc.attach(servoPin);
  sc.write(0);
  delay(1000);

  //GetRtc(); 
  
  //imposto timer per visualizzazione delle cifre dell'ora
  tm.init();
  //impostazione callback a scatto del timer  per visualizzazione dell'ora
  tm.cback(visOra);  

  //imposto timer per cucu
  tcucu.init();
  //imposto callback per scatto del cucu ogni 2 secondi
  tcucu.cback(playCucu);

//  SetRtc(0, 32, 19, 3, 9, 5, 23);	//sec, min, hour, dayOfWeek (sun,mon, tue,...), dayOfMonth, month, year
}

//main loop

void loop() {

//timer per visualizzazione cifre orologio
  tm.run();

//timer per cuccu
  tcucu.run();
	
//verifica pressione dei pulsanti per impostazione ora
  testPressedButton();	
	
//verifica se azionameto cucu
  testCucu();
}
